[
  {
    "_id": "post1",
    "author": "陈明勇",
    "category": "后端",
    "comment_count": 45,
    "content": "> 扫码关注公众号，手机阅读更方便\n> \n> ![Go技术干货](https://blog-1302954944.cos.ap-guangzhou.myqcloud.com/img/Go%E6%8A%80%E6%9C%AF%E5%B9%B2%E8%B4%A7.jpg)\n\n\n> Go 版本：1.21.0\n\n# 前言\n随着 `Go 1.21.0` 版本的发布，新增了两个实用的泛型工具库：`maps` 和 `slices`，它们分别提供了处理映射（`map`）和切片常见操作的函数，减少了我们重复造轮子的过程，提高开发效率。本文将会对 `maps` 工具库进行介绍。\n\n准备好了吗？准备一杯你最喜欢的咖啡或茶，随着本文一探究竟吧。\n# Maps\n`maps` 是一个泛型工具库，该库包含了对任何类型都支持的实用函数，函数简介如下表所示：\n\n| 函数 | 函数签名 | 功能 |\n| ------- | ------- | ------- |\n| Clone | func Clone[M ~map[K]V, K comparable, V any](m M) M | 该函数返回 `m` 的一个副本，底层基于浅层克隆去实现，使用普通赋值的方式去设置新的键值对 |\n| Copy | func Copy[M1 ~map[K]V, M2 ~map[K]V, K comparable, V any](dst M1, src M2) | 复制 `src` 中的所有键值对到 `dst` 中，如果 `dst` 中包含 `src` 中的任意 `key`，则该 `key` 对应的 `value` 将会被覆盖 |\n| DeleteFunc | func DeleteFunc[M ~map[K]V, K comparable, V any](m M, del func(K, V) bool) | 删除 `m` 中满足 `del` 返回为 `true` 的任何键值对 |\n| Equal | func Equal[M1, M2 ~map[K]V, K, V comparable](m1 M1, m2 M2) bool | 判断两个 `map` 是否包含相同的键值对，内部使用 `==` 进行比较 |\n| EqualFunc | func EqualFunc[M1 ~map[K]V1, M2 ~map[K]V2, K comparable, V1, V2 any](m1 M1, m2 M2, eq func(V1, V2) bool) bool | 类似 `Equal` 函数，但通过 `eq` 函数进行比较值，键仍使用 `==` 进行比较 |\n\n# Clone\n`Clone` 函数接收一个 `m` 参数，该函数的功能是返回 `m` 的副本，底层基于浅层克隆去实现，使用普通赋值的方式去设置新的键值对。\n\n代码示例：\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"maps\"\n)\n\nfunc main() {\n\ttype Programmer struct {\n\t\tName string\n\t\tCity string\n\t}\n\n\tm1 := map[string]Programmer{\n\t\t\"programmer-01\": {Name: \"陈明勇\", City: \"深圳\"},\n\t\t\"programmer-02\": {Name: \"张三\", City: \"广州\"},\n\t}\n\tm2 := maps.Clone(m1)\n\tfmt.Printf(\"m1: %v\\n\", m1)\n\tfmt.Printf(\"m2: %v\\n\", m2)\n}\n\n```\n\n执行结果：\n\n```\nm1: map[programmer-01:{陈明勇 深圳} programmer-02:{张三 广州}]\nm2: map[programmer-01:{陈明勇 深圳} programmer-02:{张三 广州}]\n```\n\n上述例子中，首先创建一个 `map` 类型的变量 `m1`，然后通过 `maps.Clone()` 函数进行克隆，得到 `m2`，最后通过打印结果可知 `m2` 的值和 `m1` 的值一样。\n\n从函数的功能描述中可知，`Clone` 函数的原理是浅层克隆，那么修改克隆后的 `map` 任意 `key` 的 `value` 将有可能影响原 `map` 的 `value`。\n\n我们来看下下面的例子：\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"maps\"\n)\n\nfunc main() {\n\ttype Programmer struct {\n\t\tName string\n\t\tCity string\n\t}\n\n\tm1 := map[string]*Programmer{\n\t\t\"programmer-01\": {Name: \"陈明勇\", City: \"深圳\"},\n\t\t\"programmer-02\": {Name: \"张三\", City: \"广州\"},\n\t}\n\tfmt.Printf(\"m1: %v, %v\\n\", *m1[\"programmer-01\"], *m1[\"programmer-02\"])\n\tm2 := maps.Clone(m1)\n\tfmt.Printf(\"m2: %v, %v\\n\", *m2[\"programmer-01\"], *m2[\"programmer-02\"])\n\tm2[\"programmer-02\"].City = \"海口\"\n\tfmt.Printf(\"m2 被修改后，m1: %v, %v\\n\", *m1[\"programmer-01\"], *m1[\"programmer-02\"])\n\tfmt.Printf(\"m2 被修改后，m2: %v, %v\\n\", *m2[\"programmer-01\"], *m2[\"programmer-02\"])\n}\n\n```\n\n执行结果\n\n```\nm1: {陈明勇 深圳}, {张三 广州}\nm2: {陈明勇 深圳}, {张三 广州}\nm2 被修改后，m1: {陈明勇 深圳}, {张三 海口}\nm2 被修改后，m2: {陈明勇 深圳}, {张三 海口}\n```\n\n与前面的示例不同，这个例子中的一个关键区别在于 `value` 是指针类型。从执行结果可以明显看出，如果 `m1` 的 `value` 是指针类型，那么在对克隆后的 `m2` 中的任意 `key` 对应的 `value` 进行修改操作后，都会直接影响到 `m1`。这是因为 `m1` 和 `m2` 共享了同一组指向相同 `Programmer` 结构体的指针，因此对一个指针的修改会在两个 `map` 中都可见。\n\n# Copy\n`Copy` 函数接收两个 `map` 参数 `dst` 和 `src`，该函数的功能是复制 `src` 中的所有键值对到 `dst` 中，如果 `dst` 中包含 `src` 中的任意 `key`，则该 `key` 对应的 `value` 将会被覆盖。\n\n代码示例：\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"maps\"\n)\n\nfunc main() {\n\tm1 := map[string]string{\"Name\": \"陈明勇\", \"City\": \"深圳\"}\n\tm2 := map[string]string{\"City\": \"广州\", \"Phone\": \"123456789\"}\n\tmaps.Copy(m1, m2)\n\n\tfmt.Println(m1)\n}\n\n```\n\n执行结果：\n\n```\nmap[City:广州 Name:陈明勇 Phone:123456789]\n```\n\n在上述例子中，首先创建了两个 `map` 变量，分别为 `m1` 和 `m2`，然后通过 `maps.Copy` 函数，将 `m2` 中的键值对复制到 `m1` 中，最后打印复制后的结果。\n\n根据结果可知，由于 `m1` 和 `m2` 都包含 `key → City`，因此在执行复制操作后， `m1` 中的 `key → City` 对应的 `value` 值会被覆盖。\n\n# DeleteFunc\n\n`DeleteFunc` 函数接收一个 `map` 类型的参数 `m` 和一个函数类型的参数 `del`。该函数的功能是删除 `m` 中满足 `del` 返回为 `true` 的任何键值对。\n\n代码示例：\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"maps\"\n)\n\nfunc main() {\n\tm1 := map[int]string{1: \"陈明勇\", 2: \"张三\", 3: \"李四\", 4: \"王五\"}\n\tmaps.DeleteFunc(m1, func(k int, v string) bool {\n\t\treturn k%2 == 0\n\t})\n\tfmt.Println(m1)\n}\n\n```\n\n执行结果：\n\n```\nmap[1:陈明勇 3:李四]\n```\n\n在上述例子中，首先创建了一个 `map` 变量 `m1`，使用 `int` 类型作为学号（`key`），`string` 类型作为姓名（`value`），然后通过 `maps.DeleteFunc` 删除学号为双数的学生，匿名函数的逻辑是 **当学号为双数时，返回 true**。\n\n总体来说这个例子相对简单，读者可根据实际应用场景进行使用 `DeleteFunc` 函数。\n\n# Equal\n`Equal` 函数接收两个 `map` 变量，函数的返回值为 `bool` 类型。该函数的功能是判断两个 `map` 是否包含相同的键值对，内部使用 `==` 进行比较。注意：`map` 类型的 `key` 和 `value` 必须是 `comparable` 类型。\n\n代码示例：\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"maps\"\n)\n\nfunc main() {\n\tm1 := map[int]int{0: 0, 1: 1, 2: 2}\n\tm2 := map[int]int{0: 0, 1: 1}\n\tm3 := map[int]int{0: 0, 1: 1, 2: 2}\n\n\tfmt.Println(maps.Equal(m1, m2)) // false\n\tfmt.Println(maps.Equal(m1, m3)) // true\n}\n\n```\n\n执行结果：\n\n```\nfalse\ntrue\n```\n\n上述例子中，首先创建了三个 `map` 类型变量，分别是 `m1`、`m2` 和 `m3`，然后通过 `maps.Equal()` 函数，对 `m1` 和 `m2` 以及 `m1` 和 `m3` 进行等价比较。执行结果与预期一致，`m1` 和 `m3` 是相等的，`m1` 和 `m2` 不相等。\n\n# EqualFunc\n`EqualFunc` 函数类似 `Equal` 函数，只不过是通过 `eq` 函数进行比较值，键仍使用 `==` 进行比较。注意： `value` 可以为任意类型（`any`）。\n\n代码示例：\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"maps\"\n)\n\nfunc main() {\n\ttype User struct {\n\t\tNickname string\n\t\tIdCard   string\n\t}\n\n\tm1 := map[int]User{0: {Nickname: \"陈明勇\", IdCard: \"111\"}, 1: {Nickname: \"张三\", IdCard: \"222\"}}\n\tm2 := map[int]User{0: {Nickname: \"陈明勇\", IdCard: \"111\"}}\n\tm3 := map[int]User{0: {Nickname: \"Go技术干货\", IdCard: \"111\"}, 1: {Nickname: \"张三\", IdCard: \"222\"}}\n\n\tfmt.Println(maps.EqualFunc(m1, m2, func(user User, user2 User) bool {\n\t\treturn user.IdCard == user2.IdCard\n\t})) // false\n\tfmt.Println(maps.EqualFunc(m1, m3, func(user User, user2 User) bool {\n\t\treturn user.IdCard == user2.IdCard\n\t})) // true\n}\n\n```\n\n执行结果：\n\n```\nfalse\ntrue\n```\n\n\n上述例子中，首先创建了三个 `map` 类型变量，分别是 `m1`、`m2` 和 `m3`。这些 `map` 使用 `int` 类型作为编号（`key`），`User` 类型作为用户信息（`value`）。\n\n接着，使用 `maps.EqualFunc()` 函数，对 `m1` 和 `m2` 以及 `m1` 和 `m3` 进行等价比较，在这个函数中，我们自定义了比较函数 `eq`，其逻辑是只要两个 `User` 结构体的 `IdCard` 相同，就认为它们是同一个人（相等）。执行结果与预期一致，`m1` 和 `m3` 是相等的，`m1` 和 `m2` 不相等。\n\n# 小结\n本文对 `Go` 工具库 `maps` 进行详细介绍，包括其提供的函数 `Clone`、`Copy`、`DeleteFunc`、`Equal` 和 `EqualFunc`，并强调了使用这些函数时需要注意的地方。\n\n总的来说，通过使用这些函数，减少了我们重复造轮子的过程，提高开发效率。\n\n你使用 `maps` 工具库了吗？感受如何，欢迎留言探讨。",
    "cover_img": "https://blog-1302954944.cos.ap-guangzhou.myqcloud.com/img/%E5%B0%81%E9%9D%A2-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2%20Go%201.21.0%20%E4%B8%AD%E7%9A%84%20maps%20%E5%B7%A5%E5%85%B7%E5%BA%93.jpg",
    "create_time": 1692806408145,
    "is_comment_allowed": true,
    "like_count": 0,
    "likes": "[]",
    "meta_description": "Description 1",
    "meta_keywords": "Keyword 1",
    "priority": 1,
    "status": 1,
    "summary": "Summary 1",
    "tags": "[后端, b]",
    "title": "Go语言啊",
    "update_time": 1692806408143,
    "visit_count": 107,
    "word_count": 500
  },
  {
    "_id": "about-me",
    "author": "陈明勇",
    "category": "about-me",
    "comment_count": 0,
    "content": "# 我\n你好呀# 他\n hahaha",
    "cover_img": "",
    "create_time": 1692806408149,
    "is_comment_allowed": true,
    "like_count": 0,
    "likes": "[]",
    "meta_description": "",
    "meta_keywords": "",
    "priority": 1,
    "status": 1,
    "summary": "关于我",
    "tags": "[]",
    "title": "关于我",
    "update_time": 1692806408143,
    "visit_count": 43,
    "word_count": 500
  },
  {
    "_id": "post2",
    "author": "陈明勇",
    "category": "后端",
    "comment_count": 45,
    "content": "> 扫码关注公众号，手机阅读更方便\n> \n> ![Go技术干货](https://blog-1302954944.cos.ap-guangzhou.myqcloud.com/img/Go%E6%8A%80%E6%9C%AF%E5%B9%B2%E8%B4%A7.jpg)\n\n\n> Go 版本：1.21.0\n\n# 前言\n随着 `Go 1.21.0` 版本的发布，新增了两个实用的泛型工具库：`maps` 和 `slices`，它们分别提供了处理映射（`map`）和切片常见操作的函数，减少了我们重复造轮子的过程，提高开发效率。本文将会对 `maps` 工具库进行介绍。\n\n准备好了吗？准备一杯你最喜欢的咖啡或茶，随着本文一探究竟吧。\n# Maps\n`maps` 是一个泛型工具库，该库包含了对任何类型都支持的实用函数，函数简介如下表所示：\n\n| 函数 | 函数签名 | 功能 |\n| ------- | ------- | ------- |\n| Clone | func Clone[M ~map[K]V, K comparable, V any](m M) M | 该函数返回 `m` 的一个副本，底层基于浅层克隆去实现，使用普通赋值的方式去设置新的键值对 |\n| Copy | func Copy[M1 ~map[K]V, M2 ~map[K]V, K comparable, V any](dst M1, src M2) | 复制 `src` 中的所有键值对到 `dst` 中，如果 `dst` 中包含 `src` 中的任意 `key`，则该 `key` 对应的 `value` 将会被覆盖 |\n| DeleteFunc | func DeleteFunc[M ~map[K]V, K comparable, V any](m M, del func(K, V) bool) | 删除 `m` 中满足 `del` 返回为 `true` 的任何键值对 |\n| Equal | func Equal[M1, M2 ~map[K]V, K, V comparable](m1 M1, m2 M2) bool | 判断两个 `map` 是否包含相同的键值对，内部使用 `==` 进行比较 |\n| EqualFunc | func EqualFunc[M1 ~map[K]V1, M2 ~map[K]V2, K comparable, V1, V2 any](m1 M1, m2 M2, eq func(V1, V2) bool) bool | 类似 `Equal` 函数，但通过 `eq` 函数进行比较值，键仍使用 `==` 进行比较 |\n\n# Clone\n`Clone` 函数接收一个 `m` 参数，该函数的功能是返回 `m` 的副本，底层基于浅层克隆去实现，使用普通赋值的方式去设置新的键值对。\n\n代码示例：\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"maps\"\n)\n\nfunc main() {\n\ttype Programmer struct {\n\t\tName string\n\t\tCity string\n\t}\n\n\tm1 := map[string]Programmer{\n\t\t\"programmer-01\": {Name: \"陈明勇\", City: \"深圳\"},\n\t\t\"programmer-02\": {Name: \"张三\", City: \"广州\"},\n\t}\n\tm2 := maps.Clone(m1)\n\tfmt.Printf(\"m1: %v\\n\", m1)\n\tfmt.Printf(\"m2: %v\\n\", m2)\n}\n\n```\n\n执行结果：\n\n```\nm1: map[programmer-01:{陈明勇 深圳} programmer-02:{张三 广州}]\nm2: map[programmer-01:{陈明勇 深圳} programmer-02:{张三 广州}]\n```\n\n上述例子中，首先创建一个 `map` 类型的变量 `m1`，然后通过 `maps.Clone()` 函数进行克隆，得到 `m2`，最后通过打印结果可知 `m2` 的值和 `m1` 的值一样。\n\n从函数的功能描述中可知，`Clone` 函数的原理是浅层克隆，那么修改克隆后的 `map` 任意 `key` 的 `value` 将有可能影响原 `map` 的 `value`。\n\n我们来看下下面的例子：\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"maps\"\n)\n\nfunc main() {\n\ttype Programmer struct {\n\t\tName string\n\t\tCity string\n\t}\n\n\tm1 := map[string]*Programmer{\n\t\t\"programmer-01\": {Name: \"陈明勇\", City: \"深圳\"},\n\t\t\"programmer-02\": {Name: \"张三\", City: \"广州\"},\n\t}\n\tfmt.Printf(\"m1: %v, %v\\n\", *m1[\"programmer-01\"], *m1[\"programmer-02\"])\n\tm2 := maps.Clone(m1)\n\tfmt.Printf(\"m2: %v, %v\\n\", *m2[\"programmer-01\"], *m2[\"programmer-02\"])\n\tm2[\"programmer-02\"].City = \"海口\"\n\tfmt.Printf(\"m2 被修改后，m1: %v, %v\\n\", *m1[\"programmer-01\"], *m1[\"programmer-02\"])\n\tfmt.Printf(\"m2 被修改后，m2: %v, %v\\n\", *m2[\"programmer-01\"], *m2[\"programmer-02\"])\n}\n\n```\n\n执行结果\n\n```\nm1: {陈明勇 深圳}, {张三 广州}\nm2: {陈明勇 深圳}, {张三 广州}\nm2 被修改后，m1: {陈明勇 深圳}, {张三 海口}\nm2 被修改后，m2: {陈明勇 深圳}, {张三 海口}\n```\n\n与前面的示例不同，这个例子中的一个关键区别在于 `value` 是指针类型。从执行结果可以明显看出，如果 `m1` 的 `value` 是指针类型，那么在对克隆后的 `m2` 中的任意 `key` 对应的 `value` 进行修改操作后，都会直接影响到 `m1`。这是因为 `m1` 和 `m2` 共享了同一组指向相同 `Programmer` 结构体的指针，因此对一个指针的修改会在两个 `map` 中都可见。\n\n# Copy\n`Copy` 函数接收两个 `map` 参数 `dst` 和 `src`，该函数的功能是复制 `src` 中的所有键值对到 `dst` 中，如果 `dst` 中包含 `src` 中的任意 `key`，则该 `key` 对应的 `value` 将会被覆盖。\n\n代码示例：\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"maps\"\n)\n\nfunc main() {\n\tm1 := map[string]string{\"Name\": \"陈明勇\", \"City\": \"深圳\"}\n\tm2 := map[string]string{\"City\": \"广州\", \"Phone\": \"123456789\"}\n\tmaps.Copy(m1, m2)\n\n\tfmt.Println(m1)\n}\n\n```\n\n执行结果：\n\n```\nmap[City:广州 Name:陈明勇 Phone:123456789]\n```\n\n在上述例子中，首先创建了两个 `map` 变量，分别为 `m1` 和 `m2`，然后通过 `maps.Copy` 函数，将 `m2` 中的键值对复制到 `m1` 中，最后打印复制后的结果。\n\n根据结果可知，由于 `m1` 和 `m2` 都包含 `key → City`，因此在执行复制操作后， `m1` 中的 `key → City` 对应的 `value` 值会被覆盖。\n\n# DeleteFunc\n\n`DeleteFunc` 函数接收一个 `map` 类型的参数 `m` 和一个函数类型的参数 `del`。该函数的功能是删除 `m` 中满足 `del` 返回为 `true` 的任何键值对。\n\n代码示例：\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"maps\"\n)\n\nfunc main() {\n\tm1 := map[int]string{1: \"陈明勇\", 2: \"张三\", 3: \"李四\", 4: \"王五\"}\n\tmaps.DeleteFunc(m1, func(k int, v string) bool {\n\t\treturn k%2 == 0\n\t})\n\tfmt.Println(m1)\n}\n\n```\n\n执行结果：\n\n```\nmap[1:陈明勇 3:李四]\n```\n\n在上述例子中，首先创建了一个 `map` 变量 `m1`，使用 `int` 类型作为学号（`key`），`string` 类型作为姓名（`value`），然后通过 `maps.DeleteFunc` 删除学号为双数的学生，匿名函数的逻辑是 **当学号为双数时，返回 true**。\n\n总体来说这个例子相对简单，读者可根据实际应用场景进行使用 `DeleteFunc` 函数。\n\n# Equal\n`Equal` 函数接收两个 `map` 变量，函数的返回值为 `bool` 类型。该函数的功能是判断两个 `map` 是否包含相同的键值对，内部使用 `==` 进行比较。注意：`map` 类型的 `key` 和 `value` 必须是 `comparable` 类型。\n\n代码示例：\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"maps\"\n)\n\nfunc main() {\n\tm1 := map[int]int{0: 0, 1: 1, 2: 2}\n\tm2 := map[int]int{0: 0, 1: 1}\n\tm3 := map[int]int{0: 0, 1: 1, 2: 2}\n\n\tfmt.Println(maps.Equal(m1, m2)) // false\n\tfmt.Println(maps.Equal(m1, m3)) // true\n}\n\n```\n\n执行结果：\n\n```\nfalse\ntrue\n```\n\n上述例子中，首先创建了三个 `map` 类型变量，分别是 `m1`、`m2` 和 `m3`，然后通过 `maps.Equal()` 函数，对 `m1` 和 `m2` 以及 `m1` 和 `m3` 进行等价比较。执行结果与预期一致，`m1` 和 `m3` 是相等的，`m1` 和 `m2` 不相等。\n\n# EqualFunc\n`EqualFunc` 函数类似 `Equal` 函数，只不过是通过 `eq` 函数进行比较值，键仍使用 `==` 进行比较。注意： `value` 可以为任意类型（`any`）。\n\n代码示例：\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"maps\"\n)\n\nfunc main() {\n\ttype User struct {\n\t\tNickname string\n\t\tIdCard   string\n\t}\n\n\tm1 := map[int]User{0: {Nickname: \"陈明勇\", IdCard: \"111\"}, 1: {Nickname: \"张三\", IdCard: \"222\"}}\n\tm2 := map[int]User{0: {Nickname: \"陈明勇\", IdCard: \"111\"}}\n\tm3 := map[int]User{0: {Nickname: \"Go技术干货\", IdCard: \"111\"}, 1: {Nickname: \"张三\", IdCard: \"222\"}}\n\n\tfmt.Println(maps.EqualFunc(m1, m2, func(user User, user2 User) bool {\n\t\treturn user.IdCard == user2.IdCard\n\t})) // false\n\tfmt.Println(maps.EqualFunc(m1, m3, func(user User, user2 User) bool {\n\t\treturn user.IdCard == user2.IdCard\n\t})) // true\n}\n\n```\n\n执行结果：\n\n```\nfalse\ntrue\n```\n\n\n上述例子中，首先创建了三个 `map` 类型变量，分别是 `m1`、`m2` 和 `m3`。这些 `map` 使用 `int` 类型作为编号（`key`），`User` 类型作为用户信息（`value`）。\n\n接着，使用 `maps.EqualFunc()` 函数，对 `m1` 和 `m2` 以及 `m1` 和 `m3` 进行等价比较，在这个函数中，我们自定义了比较函数 `eq`，其逻辑是只要两个 `User` 结构体的 `IdCard` 相同，就认为它们是同一个人（相等）。执行结果与预期一致，`m1` 和 `m3` 是相等的，`m1` 和 `m2` 不相等。\n\n# 小结\n本文对 `Go` 工具库 `maps` 进行详细介绍，包括其提供的函数 `Clone`、`Copy`、`DeleteFunc`、`Equal` 和 `EqualFunc`，并强调了使用这些函数时需要注意的地方。\n\n总的来说，通过使用这些函数，减少了我们重复造轮子的过程，提高开发效率。\n\n你使用 `maps` 工具库了吗？感受如何，欢迎留言探讨。",
    "cover_img": "https://blog-1302954944.cos.ap-guangzhou.myqcloud.com/img/%E5%B0%81%E9%9D%A2-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2%20Go%201.21.0%20%E4%B8%AD%E7%9A%84%20maps%20%E5%B7%A5%E5%85%B7%E5%BA%93.jpg",
    "create_time": 1703436316000,
    "is_comment_allowed": true,
    "like_count": 0,
    "likes": "[]",
    "meta_description": "Description 1",
    "meta_keywords": "Keyword 1",
    "priority": 1,
    "status": 1,
    "summary": "Summary 1",
    "tags": "[Go]",
    "title": "Go2",
    "update_time": 1703436316000,
    "visit_count": 107,
    "word_count": 500
  },
  {
    "_id": "post3",
    "author": "陈明勇",
    "category": "后端",
    "comment_count": 45,
    "content": "> 扫码关注公众号，手机阅读更方便\n> \n> ![Go技术干货](https://blog-1302954944.cos.ap-guangzhou.myqcloud.com/img/Go%E6%8A%80%E6%9C%AF%E5%B9%B2%E8%B4%A7.jpg)\n\n\n> Go 版本：1.21.0\n\n# 前言\n随着 `Go 1.21.0` 版本的发布，新增了两个实用的泛型工具库：`maps` 和 `slices`，它们分别提供了处理映射（`map`）和切片常见操作的函数，减少了我们重复造轮子的过程，提高开发效率。本文将会对 `maps` 工具库进行介绍。\n\n准备好了吗？准备一杯你最喜欢的咖啡或茶，随着本文一探究竟吧。\n# Maps\n`maps` 是一个泛型工具库，该库包含了对任何类型都支持的实用函数，函数简介如下表所示：\n\n| 函数 | 函数签名 | 功能 |\n| ------- | ------- | ------- |\n| Clone | func Clone[M ~map[K]V, K comparable, V any](m M) M | 该函数返回 `m` 的一个副本，底层基于浅层克隆去实现，使用普通赋值的方式去设置新的键值对 |\n| Copy | func Copy[M1 ~map[K]V, M2 ~map[K]V, K comparable, V any](dst M1, src M2) | 复制 `src` 中的所有键值对到 `dst` 中，如果 `dst` 中包含 `src` 中的任意 `key`，则该 `key` 对应的 `value` 将会被覆盖 |\n| DeleteFunc | func DeleteFunc[M ~map[K]V, K comparable, V any](m M, del func(K, V) bool) | 删除 `m` 中满足 `del` 返回为 `true` 的任何键值对 |\n| Equal | func Equal[M1, M2 ~map[K]V, K, V comparable](m1 M1, m2 M2) bool | 判断两个 `map` 是否包含相同的键值对，内部使用 `==` 进行比较 |\n| EqualFunc | func EqualFunc[M1 ~map[K]V1, M2 ~map[K]V2, K comparable, V1, V2 any](m1 M1, m2 M2, eq func(V1, V2) bool) bool | 类似 `Equal` 函数，但通过 `eq` 函数进行比较值，键仍使用 `==` 进行比较 |\n\n# Clone\n`Clone` 函数接收一个 `m` 参数，该函数的功能是返回 `m` 的副本，底层基于浅层克隆去实现，使用普通赋值的方式去设置新的键值对。\n\n代码示例：\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"maps\"\n)\n\nfunc main() {\n\ttype Programmer struct {\n\t\tName string\n\t\tCity string\n\t}\n\n\tm1 := map[string]Programmer{\n\t\t\"programmer-01\": {Name: \"陈明勇\", City: \"深圳\"},\n\t\t\"programmer-02\": {Name: \"张三\", City: \"广州\"},\n\t}\n\tm2 := maps.Clone(m1)\n\tfmt.Printf(\"m1: %v\\n\", m1)\n\tfmt.Printf(\"m2: %v\\n\", m2)\n}\n\n```\n\n执行结果：\n\n```\nm1: map[programmer-01:{陈明勇 深圳} programmer-02:{张三 广州}]\nm2: map[programmer-01:{陈明勇 深圳} programmer-02:{张三 广州}]\n```\n\n上述例子中，首先创建一个 `map` 类型的变量 `m1`，然后通过 `maps.Clone()` 函数进行克隆，得到 `m2`，最后通过打印结果可知 `m2` 的值和 `m1` 的值一样。\n\n从函数的功能描述中可知，`Clone` 函数的原理是浅层克隆，那么修改克隆后的 `map` 任意 `key` 的 `value` 将有可能影响原 `map` 的 `value`。\n\n我们来看下下面的例子：\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"maps\"\n)\n\nfunc main() {\n\ttype Programmer struct {\n\t\tName string\n\t\tCity string\n\t}\n\n\tm1 := map[string]*Programmer{\n\t\t\"programmer-01\": {Name: \"陈明勇\", City: \"深圳\"},\n\t\t\"programmer-02\": {Name: \"张三\", City: \"广州\"},\n\t}\n\tfmt.Printf(\"m1: %v, %v\\n\", *m1[\"programmer-01\"], *m1[\"programmer-02\"])\n\tm2 := maps.Clone(m1)\n\tfmt.Printf(\"m2: %v, %v\\n\", *m2[\"programmer-01\"], *m2[\"programmer-02\"])\n\tm2[\"programmer-02\"].City = \"海口\"\n\tfmt.Printf(\"m2 被修改后，m1: %v, %v\\n\", *m1[\"programmer-01\"], *m1[\"programmer-02\"])\n\tfmt.Printf(\"m2 被修改后，m2: %v, %v\\n\", *m2[\"programmer-01\"], *m2[\"programmer-02\"])\n}\n\n```\n\n执行结果\n\n```\nm1: {陈明勇 深圳}, {张三 广州}\nm2: {陈明勇 深圳}, {张三 广州}\nm2 被修改后，m1: {陈明勇 深圳}, {张三 海口}\nm2 被修改后，m2: {陈明勇 深圳}, {张三 海口}\n```\n\n与前面的示例不同，这个例子中的一个关键区别在于 `value` 是指针类型。从执行结果可以明显看出，如果 `m1` 的 `value` 是指针类型，那么在对克隆后的 `m2` 中的任意 `key` 对应的 `value` 进行修改操作后，都会直接影响到 `m1`。这是因为 `m1` 和 `m2` 共享了同一组指向相同 `Programmer` 结构体的指针，因此对一个指针的修改会在两个 `map` 中都可见。\n\n# Copy\n`Copy` 函数接收两个 `map` 参数 `dst` 和 `src`，该函数的功能是复制 `src` 中的所有键值对到 `dst` 中，如果 `dst` 中包含 `src` 中的任意 `key`，则该 `key` 对应的 `value` 将会被覆盖。\n\n代码示例：\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"maps\"\n)\n\nfunc main() {\n\tm1 := map[string]string{\"Name\": \"陈明勇\", \"City\": \"深圳\"}\n\tm2 := map[string]string{\"City\": \"广州\", \"Phone\": \"123456789\"}\n\tmaps.Copy(m1, m2)\n\n\tfmt.Println(m1)\n}\n\n```\n\n执行结果：\n\n```\nmap[City:广州 Name:陈明勇 Phone:123456789]\n```\n\n在上述例子中，首先创建了两个 `map` 变量，分别为 `m1` 和 `m2`，然后通过 `maps.Copy` 函数，将 `m2` 中的键值对复制到 `m1` 中，最后打印复制后的结果。\n\n根据结果可知，由于 `m1` 和 `m2` 都包含 `key → City`，因此在执行复制操作后， `m1` 中的 `key → City` 对应的 `value` 值会被覆盖。\n\n# DeleteFunc\n\n`DeleteFunc` 函数接收一个 `map` 类型的参数 `m` 和一个函数类型的参数 `del`。该函数的功能是删除 `m` 中满足 `del` 返回为 `true` 的任何键值对。\n\n代码示例：\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"maps\"\n)\n\nfunc main() {\n\tm1 := map[int]string{1: \"陈明勇\", 2: \"张三\", 3: \"李四\", 4: \"王五\"}\n\tmaps.DeleteFunc(m1, func(k int, v string) bool {\n\t\treturn k%2 == 0\n\t})\n\tfmt.Println(m1)\n}\n\n```\n\n执行结果：\n\n```\nmap[1:陈明勇 3:李四]\n```\n\n在上述例子中，首先创建了一个 `map` 变量 `m1`，使用 `int` 类型作为学号（`key`），`string` 类型作为姓名（`value`），然后通过 `maps.DeleteFunc` 删除学号为双数的学生，匿名函数的逻辑是 **当学号为双数时，返回 true**。\n\n总体来说这个例子相对简单，读者可根据实际应用场景进行使用 `DeleteFunc` 函数。\n\n# Equal\n`Equal` 函数接收两个 `map` 变量，函数的返回值为 `bool` 类型。该函数的功能是判断两个 `map` 是否包含相同的键值对，内部使用 `==` 进行比较。注意：`map` 类型的 `key` 和 `value` 必须是 `comparable` 类型。\n\n代码示例：\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"maps\"\n)\n\nfunc main() {\n\tm1 := map[int]int{0: 0, 1: 1, 2: 2}\n\tm2 := map[int]int{0: 0, 1: 1}\n\tm3 := map[int]int{0: 0, 1: 1, 2: 2}\n\n\tfmt.Println(maps.Equal(m1, m2)) // false\n\tfmt.Println(maps.Equal(m1, m3)) // true\n}\n\n```\n\n执行结果：\n\n```\nfalse\ntrue\n```\n\n上述例子中，首先创建了三个 `map` 类型变量，分别是 `m1`、`m2` 和 `m3`，然后通过 `maps.Equal()` 函数，对 `m1` 和 `m2` 以及 `m1` 和 `m3` 进行等价比较。执行结果与预期一致，`m1` 和 `m3` 是相等的，`m1` 和 `m2` 不相等。\n\n# EqualFunc\n`EqualFunc` 函数类似 `Equal` 函数，只不过是通过 `eq` 函数进行比较值，键仍使用 `==` 进行比较。注意： `value` 可以为任意类型（`any`）。\n\n代码示例：\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"maps\"\n)\n\nfunc main() {\n\ttype User struct {\n\t\tNickname string\n\t\tIdCard   string\n\t}\n\n\tm1 := map[int]User{0: {Nickname: \"陈明勇\", IdCard: \"111\"}, 1: {Nickname: \"张三\", IdCard: \"222\"}}\n\tm2 := map[int]User{0: {Nickname: \"陈明勇\", IdCard: \"111\"}}\n\tm3 := map[int]User{0: {Nickname: \"Go技术干货\", IdCard: \"111\"}, 1: {Nickname: \"张三\", IdCard: \"222\"}}\n\n\tfmt.Println(maps.EqualFunc(m1, m2, func(user User, user2 User) bool {\n\t\treturn user.IdCard == user2.IdCard\n\t})) // fa,